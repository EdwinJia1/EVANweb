<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COMP1511 - Linked Lists Quiz | Programming Fundamentals</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;
            background-color: #f8f7f2;
            color: #2c2c2c;
            line-height: 1.6;
        }
        .quiz-container {
            background-color: #ffffff;
            border-radius: 0.5rem;
            padding: 2rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            margin-bottom: 2rem;
        }
        .question-card {
            background-color: #f8f7f2;
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        .question-card.answered-correct {
            border-color: #22c55e;
            background-color: #f0fdf4;
        }
        .question-card.answered-incorrect {
            border-color: #ef4444;
            background-color: #fef2f2;
        }
        .option-button {
            width: 100%;
            text-align: left;
            padding: 0.75rem 1rem;
            margin: 0.5rem 0;
            background-color: #ffffff;
            border: 2px solid #e5e7eb;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .option-button:hover:not(.disabled) {
            border-color: #e07a5f;
            transform: translateX(5px);
        }
        .option-button.correct {
            border-color: #22c55e;
            background-color: #dcfce7;
        }
        .option-button.incorrect {
            border-color: #ef4444;
            background-color: #fee2e2;
        }
        .option-button.disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }
        .explanation {
            margin-top: 1rem;
            padding: 1rem;
            background-color: #e0f2fe;
            border-left: 4px solid #0ea5e9;
            border-radius: 0 0.375rem 0.375rem 0;
            display: none;
        }
        .explanation.show {
            display: block;
        }
        .difficulty-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        .difficulty-easy {
            background-color: #dcfce7;
            color: #166534;
        }
        .difficulty-medium {
            background-color: #fed7aa;
            color: #9a3412;
        }
        .difficulty-hard {
            background-color: #ddd6fe;
            color: #5b21b6;
        }
        .difficulty-extreme {
            background-color: #fecaca;
            color: #991b1b;
        }
        .progress-bar {
            width: 100%;
            height: 1rem;
            background-color: #e5e7eb;
            border-radius: 9999px;
            overflow: hidden;
            margin-bottom: 2rem;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #e07a5f 0%, #f4a261 100%);
            transition: width 0.3s ease;
        }
        .stats-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
        }
        .stat-card {
            background-color: #ffffff;
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: center;
            box-shadow: 0 2px 4px -1px rgb(0 0 0 / 0.1);
        }
        .back-button {
            background-color: #f8f7f2;
            color: #2c2c2c;
            border: 2px solid #e07a5f;
            border-radius: 0.5rem;
            padding: 0.75rem 1.5rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 2rem;
        }
        .back-button:hover {
            background-color: #e07a5f;
            color: #ffffff;
            transform: translateY(-2px);
        }
        .update-notice {
            background-color: #fff7ed;
            border: 2px solid #f4a261;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 2rem;
            text-align: center;
        }
        .section-header {
            background: linear-gradient(135deg, #e07a5f 0%, #f4a261 100%);
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            margin: 2rem 0 1rem 0;
            text-align: center;
        }
        .code-block {
            background-color: #2c2c2c;
            color: #ffffff;
            padding: 1rem;
            border-radius: 0.375rem;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            overflow-x: auto;
            margin: 1rem 0;
        }
        .interactive-simulator {
            background-color: #f8f9fa;
            border: 2px dashed #e07a5f;
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin: 1rem 0;
            text-align: center;
        }
        .simulator-button {
            background-color: #e07a5f;
            color: #ffffff;
            border: none;
            border-radius: 0.375rem;
            padding: 0.5rem 1rem;
            margin: 0.25rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .simulator-button:hover {
            background-color: #d06850;
        }
        .simulator-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .node-visual {
            display: inline-flex;
            border: 2px solid #e07a5f;
            border-radius: 0.375rem;
            overflow: hidden;
            margin: 0.5rem;
            background-color: #ffffff;
        }
        .node-data {
            padding: 0.5rem 1rem;
            background-color: #e07a5f;
            color: #ffffff;
            font-weight: 600;
        }
        .node-pointer {
            padding: 0.5rem;
            background-color: #f8f7f2;
            color: #2c2c2c;
            min-width: 3rem;
            text-align: center;
        }
        .code-editor {
            width: 100%;
            min-height: 150px;
            background-color: #2c2c2c;
            color: #ffffff;
            border: 2px solid #e5e7eb;
            border-radius: 0.375rem;
            padding: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            resize: vertical;
        }
        .compile-button {
            background-color: #22c55e;
            color: #ffffff;
            border: none;
            border-radius: 0.375rem;
            padding: 0.75rem 1.5rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 1rem;
        }
        .compile-button:hover {
            background-color: #16a34a;
        }
        .compile-output {
            background-color: #1f2937;
            color: #10b981;
            border-radius: 0.375rem;
            padding: 1rem;
            margin-top: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            display: none;
        }
        .compile-output.show {
            display: block;
        }
    </style>
</head>
<body class="antialiased">
    <div class="container mx-auto px-4 py-8 md:py-12 max-w-4xl">
        
        <!-- Navigation -->
        <a href="../comp1511.html" class="back-button">
            <span>â†</span>
            <span>Back to COMP1511</span>
        </a>

        <!-- Update Notice -->
        <div class="update-notice">
            <h3 class="font-bold text-lg text-[#e07a5f] mb-2">ğŸ”— é“¾è¡¨ä¸“é¡¹æµ‹éªŒ</h3>
            <p class="text-gray-700">æ·±å…¥æµ‹è¯•æ‚¨å¯¹é“¾è¡¨æ•°æ®ç»“æ„çš„ç†è§£ï¼ŒåŒ…å«æ¦‚å¿µã€ä»£ç é˜…è¯»ã€äº¤äº’æ¨¡æ‹Ÿå’Œç¼–ç¨‹å®è·µã€‚</p>
        </div>

        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-[#2c2c2c]">COMP1511 - Linked Lists Quiz</h1>
            <p class="text-xl text-gray-600 mt-2">é“¾è¡¨ä¸“é¡¹æµ‹éªŒ</p>
            <p class="text-sm text-gray-500 mt-1">50 questions: 15 easy, 20 medium, 10 hard, 5 extreme</p>
        </header>

        <!-- Progress Bar -->
        <div class="progress-bar">
            <div class="progress-fill" id="progressBar" style="width: 0%"></div>
        </div>

        <!-- Stats -->
        <div class="stats-container">
            <div class="stat-card">
                <h3 class="text-2xl font-bold text-[#e07a5f]" id="scoreDisplay">0/0</h3>
                <p class="text-gray-600">æ€»åˆ†</p>
            </div>
            <div class="stat-card">
                <h3 class="text-2xl font-bold text-[#22c55e]" id="correctDisplay">0</h3>
                <p class="text-gray-600">æ­£ç¡®</p>
            </div>
            <div class="stat-card">
                <h3 class="text-2xl font-bold text-[#ef4444]" id="incorrectDisplay">0</h3>
                <p class="text-gray-600">é”™è¯¯</p>
            </div>
        </div>

        <!-- Quiz Container -->
        <div class="quiz-container" id="quizContainer">
            <!-- Questions will be dynamically inserted here -->
        </div>
    </div>

    <script>
        let currentQuestion = 0;
        let correctAnswers = 0;
        let incorrectAnswers = 0;

        const questions = [
            // Easy Questions (15)
            {
                type: 'easy',
                question: 'ä»€ä¹ˆæ˜¯é“¾è¡¨ï¼Ÿ',
                options: [
                    'ä¸€ç§çº¿æ€§æ•°æ®ç»“æ„ï¼Œå…ƒç´ åœ¨å†…å­˜ä¸­è¿ç»­å­˜å‚¨',
                    'ä¸€ç§çº¿æ€§æ•°æ®ç»“æ„ï¼Œå…ƒç´ é€šè¿‡æŒ‡é’ˆè¿æ¥',
                    'ä¸€ç§éçº¿æ€§æ•°æ®ç»“æ„ï¼Œç±»ä¼¼äºæ ‘',
                    'ä¸€ç§æ’åºç®—æ³•'
                ],
                correct: 1,
                explanation: 'é“¾è¡¨æ˜¯ä¸€ç§çº¿æ€§æ•°æ®ç»“æ„ï¼Œå…¶ä¸­å…ƒç´ ï¼ˆèŠ‚ç‚¹ï¼‰é€šè¿‡æŒ‡é’ˆè¿æ¥ï¼Œä¸éœ€è¦åœ¨å†…å­˜ä¸­è¿ç»­å­˜å‚¨ã€‚'
            },
            {
                type: 'easy',
                question: 'åœ¨é“¾è¡¨ä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹é€šå¸¸åŒ…å«ä»€ä¹ˆï¼Ÿ',
                options: [
                    'åªæœ‰æ•°æ®',
                    'åªæœ‰æŒ‡é’ˆ',
                    'æ•°æ®å’ŒæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ',
                    'æ•°æ®å’ŒæŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ'
                ],
                correct: 2,
                explanation: 'åœ¨å•é“¾è¡¨ä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«æ•°æ®éƒ¨åˆ†å’ŒæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆã€‚'
            },
            {
                type: 'easy',
                question: 'é“¾è¡¨ç›¸æ¯”æ•°ç»„çš„ä¸»è¦ä¼˜åŠ¿æ˜¯ä»€ä¹ˆï¼Ÿ',
                options: [
                    'è®¿é—®å…ƒç´ æ›´å¿«',
                    'å ç”¨å†…å­˜æ›´å°‘',
                    'åŠ¨æ€åˆ†é…å†…å­˜ï¼Œå¤§å°å¯å˜',
                    'å…ƒç´ è‡ªåŠ¨æ’åº'
                ],
                correct: 2,
                explanation: 'é“¾è¡¨çš„ä¸»è¦ä¼˜åŠ¿æ˜¯å¯ä»¥åŠ¨æ€åˆ†é…å†…å­˜ï¼Œåœ¨è¿è¡Œæ—¶æ”¹å˜å¤§å°ï¼Œè€Œæ•°ç»„å¤§å°åœ¨å£°æ˜æ—¶å°±å›ºå®šäº†ã€‚'
            },
            {
                type: 'easy',
                question: 'è®¿é—®é“¾è¡¨ç¬¬nä¸ªå…ƒç´ çš„æ—¶é—´å¤æ‚åº¦æ˜¯å¤šå°‘ï¼Ÿ',
                options: [
                    'O(1)',
                    'O(log n)',
                    'O(n)',
                    'O(nÂ²)'
                ],
                correct: 2,
                explanation: 'è®¿é—®é“¾è¡¨ç¬¬nä¸ªå…ƒç´ éœ€è¦ä»å¤´èŠ‚ç‚¹å¼€å§‹éå†ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦æ˜¯O(n)ã€‚'
            },
            {
                type: 'easy',
                question: 'åœ¨é“¾è¡¨å¤´éƒ¨æ’å…¥ä¸€ä¸ªæ–°èŠ‚ç‚¹çš„æ—¶é—´å¤æ‚åº¦æ˜¯å¤šå°‘ï¼Ÿ',
                options: [
                    'O(1)',
                    'O(log n)',
                    'O(n)',
                    'O(nÂ²)'
                ],
                correct: 0,
                explanation: 'åœ¨é“¾è¡¨å¤´éƒ¨æ’å…¥èŠ‚ç‚¹åªéœ€è¦ä¿®æ”¹å‡ ä¸ªæŒ‡é’ˆï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯O(1)ã€‚'
            },
            {
                type: 'easy',
                question: 'ä»€ä¹ˆæ˜¯ç©ºé“¾è¡¨ï¼Ÿ',
                options: [
                    'å¤´æŒ‡é’ˆæŒ‡å‘ç¬¬ä¸€ä¸ªèŠ‚ç‚¹',
                    'å¤´æŒ‡é’ˆä¸ºNULL',
                    'åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„é“¾è¡¨',
                    'æ‰€æœ‰èŠ‚ç‚¹æ•°æ®éƒ½ä¸º0çš„é“¾è¡¨'
                ],
                correct: 1,
                explanation: 'ç©ºé“¾è¡¨æ˜¯æŒ‡å¤´æŒ‡é’ˆä¸ºNULLï¼Œè¡¨ç¤ºé“¾è¡¨ä¸­æ²¡æœ‰ä»»ä½•èŠ‚ç‚¹ã€‚'
            },
            {
                type: 'easy',
                question: 'é“¾è¡¨èŠ‚ç‚¹é€šå¸¸ä½¿ç”¨ä»€ä¹ˆæ¥å®ç°ï¼Ÿ',
                options: [
                    'æ•°ç»„',
                    'ç»“æ„ä½“ï¼ˆstructï¼‰',
                    'å‡½æ•°',
                    'å®å®šä¹‰'
                ],
                correct: 1,
                explanation: 'é“¾è¡¨èŠ‚ç‚¹é€šå¸¸ä½¿ç”¨ç»“æ„ä½“ï¼ˆstructï¼‰æ¥å®ç°ï¼ŒåŒ…å«æ•°æ®å­—æ®µå’ŒæŒ‡é’ˆå­—æ®µã€‚'
            },
            {
                type: 'easy',
                question: 'åŒå‘é“¾è¡¨æ¯”å•å‘é“¾è¡¨å¤šäº†ä»€ä¹ˆï¼Ÿ',
                options: [
                    'æ›´å¤šçš„æ•°æ®',
                    'æŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ',
                    'æ›´å¿«çš„è®¿é—®é€Ÿåº¦',
                    'è‡ªåŠ¨æ’åºåŠŸèƒ½'
                ],
                correct: 1,
                explanation: 'åŒå‘é“¾è¡¨çš„æ¯ä¸ªèŠ‚ç‚¹é™¤äº†æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆå¤–ï¼Œè¿˜æœ‰æŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆã€‚'
            },
            {
                type: 'easy',
                question: 'åˆ é™¤é“¾è¡¨ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹åï¼Œåº”è¯¥æ€ä¹ˆå¤„ç†è¢«åˆ é™¤çš„èŠ‚ç‚¹ï¼Ÿ',
                options: [
                    'ä»€ä¹ˆéƒ½ä¸åš',
                    'å°†æ•°æ®è®¾ä¸º0',
                    'ä½¿ç”¨free()é‡Šæ”¾å†…å­˜',
                    'å°†æŒ‡é’ˆè®¾ä¸ºNULL'
                ],
                correct: 2,
                explanation: 'åˆ é™¤èŠ‚ç‚¹ååº”è¯¥ä½¿ç”¨free()é‡Šæ”¾å†…å­˜ï¼Œé¿å…å†…å­˜æ³„æ¼ã€‚'
            },
            {
                type: 'easy',
                question: 'é“¾è¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹é€šå¸¸è¢«ç§°ä¸ºä»€ä¹ˆï¼Ÿ',
                options: [
                    'å°¾èŠ‚ç‚¹',
                    'å¤´èŠ‚ç‚¹',
                    'æ ¹èŠ‚ç‚¹',
                    'èµ·å§‹èŠ‚ç‚¹'
                ],
                correct: 1,
                explanation: 'é“¾è¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹é€šå¸¸è¢«ç§°ä¸ºå¤´èŠ‚ç‚¹ï¼ˆhead nodeï¼‰ã€‚'
            },
            {
                type: 'easy',
                question: 'å¾ªç¯é“¾è¡¨çš„ç‰¹ç‚¹æ˜¯ä»€ä¹ˆï¼Ÿ',
                options: [
                    'å¯ä»¥æ— é™å¢é•¿',
                    'æœ€åä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘ç¬¬ä¸€ä¸ªèŠ‚ç‚¹',
                    'èŠ‚ç‚¹å¯ä»¥é‡å¤',
                    'æ•°æ®å¯ä»¥å¾ªç¯'
                ],
                correct: 1,
                explanation: 'å¾ªç¯é“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆæŒ‡å‘ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå½¢æˆä¸€ä¸ªç¯ã€‚'
            },
            {
                type: 'easy',
                question: 'åˆ›å»ºæ–°é“¾è¡¨èŠ‚ç‚¹æ—¶é€šå¸¸ä½¿ç”¨ä»€ä¹ˆå‡½æ•°ï¼Ÿ',
                options: [
                    'malloc()',
                    'calloc()',
                    'new()',
                    'ä»¥ä¸Šéƒ½å¯ä»¥'
                ],
                correct: 3,
                explanation: 'malloc()å’Œcalloc()éƒ½å¯ä»¥ç”¨æ¥åˆ†é…å†…å­˜åˆ›å»ºæ–°èŠ‚ç‚¹ï¼Œnew()æ˜¯C++ä¸­çš„æ“ä½œç¬¦ã€‚'
            },
            {
                type: 'easy',
                question: 'é“¾è¡¨ä¸­æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆåŸŸé€šå¸¸è®¾ä¸ºä»€ä¹ˆï¼Ÿ',
                options: [
                    '0',
                    'NULL',
                    '-1',
                    'æŒ‡å‘è‡ªå·±'
                ],
                correct: 1,
                explanation: 'é“¾è¡¨ä¸­æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆåŸŸé€šå¸¸è®¾ä¸ºNULLï¼Œè¡¨ç¤ºé“¾è¡¨çš„ç»“æŸã€‚'
            },
            {
                type: 'easy',
                question: 'è¦éå†æ•´ä¸ªé“¾è¡¨ï¼Œé€šå¸¸ä½¿ç”¨ä»€ä¹ˆæ–¹æ³•ï¼Ÿ',
                options: [
                    'é€’å½’',
                    'å¾ªç¯',
                    'äºŒåˆ†æŸ¥æ‰¾',
                    'ä»¥ä¸Šéƒ½å¯ä»¥'
                ],
                correct: 3,
                explanation: 'éå†é“¾è¡¨å¯ä»¥ä½¿ç”¨å¾ªç¯ï¼ˆå¦‚whileå¾ªç¯ï¼‰æˆ–é€’å½’æ–¹æ³•ï¼Œä¸¤ç§æ–¹æ³•éƒ½å¯ä»¥å®ç°ã€‚'
            },
            {
                type: 'easy',
                question: 'åœ¨Cè¯­è¨€ä¸­ï¼Œé“¾è¡¨èŠ‚ç‚¹çš„å…¸å‹å®šä¹‰åŒ…å«ä»€ä¹ˆå…³é”®å­—ï¼Ÿ',
                options: [
                    'class',
                    'struct',
                    'union',
                    'typedef'
                ],
                correct: 1,
                explanation: 'åœ¨Cè¯­è¨€ä¸­ï¼Œé“¾è¡¨èŠ‚ç‚¹é€šå¸¸ä½¿ç”¨structå…³é”®å­—æ¥å®šä¹‰ç»“æ„ä½“ã€‚'
            },

            // Medium Questions (20) - Code Reading
            {
                type: 'medium',
                question: 'ä¸‹é¢ä»£ç çš„è¾“å‡ºæ˜¯ä»€ä¹ˆï¼Ÿ',
                code: `struct Node {
    int data;
    struct Node* next;
};

int main() {
    struct Node* head = NULL;
    printf("%p\\n", head);
    return 0;
}`,
                options: [
                    '0',
                    '(null)',
                    '0x0',
                    'ä»¥ä¸Šéƒ½å¯èƒ½'
                ],
                correct: 3,
                explanation: 'NULLæŒ‡é’ˆçš„æ‰“å°ç»“æœå› ç³»ç»Ÿè€Œå¼‚ï¼Œå¯èƒ½æ˜¾ç¤ºä¸º0ã€(null)æˆ–0x0ç­‰ã€‚'
            },
            {
                type: 'medium',
                question: 'è¿™æ®µä»£ç æ‰§è¡Œåï¼Œé“¾è¡¨ä¸­æœ‰å‡ ä¸ªèŠ‚ç‚¹ï¼Ÿ',
                code: `struct Node* head = malloc(sizeof(struct Node));
head->data = 1;
head->next = malloc(sizeof(struct Node));
head->next->data = 2;
head->next->next = NULL;`,
                options: [
                    '1ä¸ª',
                    '2ä¸ª',
                    '3ä¸ª',
                    'ç¼–è¯‘é”™è¯¯'
                ],
                correct: 1,
                explanation: 'ä»£ç åˆ›å»ºäº†ä¸¤ä¸ªèŠ‚ç‚¹ï¼šç¬¬ä¸€ä¸ªèŠ‚ç‚¹æ•°æ®ä¸º1ï¼Œç¬¬äºŒä¸ªèŠ‚ç‚¹æ•°æ®ä¸º2ã€‚'
            },
            {
                type: 'medium',
                question: 'è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ',
                code: `int count_nodes(struct Node* head) {
    int count = 0;
    while (head != NULL) {
        count++;
        head = head->next;
    }
    return count;
}`,
                options: [
                    'è®¡ç®—èŠ‚ç‚¹æ•°æ®ä¹‹å’Œ',
                    'è®¡ç®—é“¾è¡¨é•¿åº¦',
                    'æŸ¥æ‰¾æœ€å¤§å€¼',
                    'åˆ é™¤æ‰€æœ‰èŠ‚ç‚¹'
                ],
                correct: 1,
                explanation: 'è¿™ä¸ªå‡½æ•°éå†é“¾è¡¨å¹¶è®¡æ•°ï¼Œè¿”å›é“¾è¡¨ä¸­èŠ‚ç‚¹çš„æ€»æ•°ã€‚'
            },
            {
                type: 'medium',
                question: 'ä»¥ä¸‹ä»£ç æœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ',
                code: `struct Node* create_node(int data) {
    struct Node new_node;
    new_node.data = data;
    new_node.next = NULL;
    return &new_node;
}`,
                options: [
                    'è¯­æ³•é”™è¯¯',
                    'è¿”å›äº†å±€éƒ¨å˜é‡çš„åœ°å€',
                    'å†…å­˜æ³„æ¼',
                    'æ²¡æœ‰é—®é¢˜'
                ],
                correct: 1,
                explanation: 'å‡½æ•°è¿”å›äº†å±€éƒ¨å˜é‡çš„åœ°å€ï¼Œå½“å‡½æ•°ç»“æŸæ—¶ï¼Œå±€éƒ¨å˜é‡è¢«é”€æ¯ï¼Œè¿”å›çš„æŒ‡é’ˆå˜ä¸ºé‡æŒ‡é’ˆã€‚'
            },
            {
                type: 'medium',
                question: 'è¿™æ®µä»£ç çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ',
                code: `struct Node* reverse_list(struct Node* head) {
    struct Node* prev = NULL;
    struct Node* current = head;
    struct Node* next = NULL;
    
    while (current != NULL) {
        next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }
    return prev;
}`,
                options: [
                    'åˆ é™¤é“¾è¡¨',
                    'åè½¬é“¾è¡¨',
                    'æ’åºé“¾è¡¨',
                    'å¤åˆ¶é“¾è¡¨'
                ],
                correct: 1,
                explanation: 'è¿™æ˜¯ç»å…¸çš„é“¾è¡¨åè½¬ç®—æ³•ï¼Œé€šè¿‡æ”¹å˜æ¯ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆæ–¹å‘æ¥åè½¬æ•´ä¸ªé“¾è¡¨ã€‚'
            },
            {
                type: 'medium',
                question: 'æ‰§è¡ŒåtempæŒ‡å‘å“ªä¸ªèŠ‚ç‚¹ï¼Ÿ',
                code: `struct Node* head; // æŒ‡å‘åŒ…å«æ•°æ®1,2,3çš„é“¾è¡¨
struct Node* temp = head->next->next;`,
                options: [
                    'ç¬¬1ä¸ªèŠ‚ç‚¹ï¼ˆæ•°æ®1ï¼‰',
                    'ç¬¬2ä¸ªèŠ‚ç‚¹ï¼ˆæ•°æ®2ï¼‰',
                    'ç¬¬3ä¸ªèŠ‚ç‚¹ï¼ˆæ•°æ®3ï¼‰',
                    'NULL'
                ],
                correct: 2,
                explanation: 'headæŒ‡å‘ç¬¬1ä¸ªèŠ‚ç‚¹ï¼Œhead->nextæŒ‡å‘ç¬¬2ä¸ªèŠ‚ç‚¹ï¼Œhead->next->nextæŒ‡å‘ç¬¬3ä¸ªèŠ‚ç‚¹ã€‚'
            },
            {
                type: 'medium',
                question: 'è¿™ä¸ªæ¡ä»¶åˆ¤æ–­ä»€ä¹ˆæ—¶å€™ä¸ºçœŸï¼Ÿ',
                code: `if (head != NULL && head->next == NULL)`,
                options: [
                    'é“¾è¡¨ä¸ºç©º',
                    'é“¾è¡¨åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹',
                    'é“¾è¡¨æœ‰ä¸¤ä¸ªèŠ‚ç‚¹',
                    'é“¾è¡¨æ˜¯å¾ªç¯çš„'
                ],
                correct: 1,
                explanation: 'head != NULLè¡¨ç¤ºé“¾è¡¨ä¸ä¸ºç©ºï¼Œhead->next == NULLè¡¨ç¤ºç¬¬ä¸€ä¸ªèŠ‚ç‚¹æ²¡æœ‰ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ‰€ä»¥é“¾è¡¨åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ã€‚'
            },
            {
                type: 'medium',
                question: 'è¿™æ®µä»£ç å¯èƒ½å¯¼è‡´ä»€ä¹ˆé—®é¢˜ï¼Ÿ',
                code: `while (current != NULL) {
    printf("%d ", current->data);
    current = current->next->next;
}`,
                options: [
                    'æ— é™å¾ªç¯',
                    'æ®µé”™è¯¯ï¼ˆSegmentation faultï¼‰',
                    'å†…å­˜æ³„æ¼',
                    'æ²¡æœ‰é—®é¢˜'
                ],
                correct: 1,
                explanation: 'å½“é“¾è¡¨èŠ‚ç‚¹æ•°ä¸ºå¥‡æ•°æ—¶ï¼Œæœ€åä¸€ä¸ªèŠ‚ç‚¹çš„nextä¸ºNULLï¼Œè®¿é—®NULL->nextä¼šå¯¼è‡´æ®µé”™è¯¯ã€‚'
            },
            {
                type: 'medium',
                question: 'è¿™ä¸ªå‡½æ•°è¿”å›ä»€ä¹ˆï¼Ÿ',
                code: `struct Node* find_middle(struct Node* head) {
    struct Node* slow = head;
    struct Node* fast = head;
    
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}`,
                options: [
                    'ç¬¬ä¸€ä¸ªèŠ‚ç‚¹',
                    'æœ€åä¸€ä¸ªèŠ‚ç‚¹',
                    'ä¸­é—´èŠ‚ç‚¹',
                    'NULL'
                ],
                correct: 2,
                explanation: 'è¿™æ˜¯å¿«æ…¢æŒ‡é’ˆæ³•ï¼Œå¿«æŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨2æ­¥ï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨1æ­¥ï¼Œå½“å¿«æŒ‡é’ˆåˆ°è¾¾æœ«å°¾æ—¶ï¼Œæ…¢æŒ‡é’ˆæ­£å¥½åœ¨ä¸­é—´ã€‚'
            },
            {
                type: 'medium',
                question: 'å¦‚ä½•æ£€æŸ¥é“¾è¡¨æ˜¯å¦æœ‰ç¯ï¼Ÿ',
                code: `bool has_cycle(struct Node* head) {
    struct Node* slow = head;
    struct Node* fast = head;
    
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) return true;
    }
    return false;
}`,
                options: [
                    'æ¯”è¾ƒèŠ‚ç‚¹æ•°æ®',
                    'ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ£€æµ‹',
                    'è®¡ç®—é“¾è¡¨é•¿åº¦',
                    'éå†ä¸¤æ¬¡'
                ],
                correct: 1,
                explanation: 'Floydåˆ¤åœˆç®—æ³•ï¼ˆå¿«æ…¢æŒ‡é’ˆï¼‰ï¼šå¦‚æœé“¾è¡¨æœ‰ç¯ï¼Œå¿«æŒ‡é’ˆæœ€ç»ˆä¼šè¿½ä¸Šæ…¢æŒ‡é’ˆã€‚'
            },
            {
                type: 'medium',
                question: 'è¿™æ®µä»£ç æ‰§è¡Œåä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ',
                code: `struct Node* node1 = malloc(sizeof(struct Node));
struct Node* node2 = malloc(sizeof(struct Node));
node1->next = node2;
node2->next = node1;
free(node1);`,
                options: [
                    'æ­£å¸¸é‡Šæ”¾å†…å­˜',
                    'å†…å­˜æ³„æ¼',
                    'node2æˆä¸ºé‡æŒ‡é’ˆ',
                    'ç¨‹åºå´©æºƒ'
                ],
                correct: 2,
                explanation: 'é‡Šæ”¾node1åï¼Œnode2->nextä»æŒ‡å‘å·²é‡Šæ”¾çš„å†…å­˜ï¼Œæˆä¸ºé‡æŒ‡é’ˆï¼Œä¸”node2çš„å†…å­˜ä¹Ÿæ²¡æœ‰é‡Šæ”¾ã€‚'
            },
            {
                type: 'medium',
                question: 'åœ¨é“¾è¡¨å¤´éƒ¨æ’å…¥èŠ‚ç‚¹çš„æ­£ç¡®æ­¥éª¤æ˜¯ä»€ä¹ˆï¼Ÿ',
                code: `struct Node* insert_at_head(struct Node* head, int data) {
    struct Node* new_node = malloc(sizeof(struct Node));
    new_node->data = data;
    // ä¸‹ä¸€æ­¥åº”è¯¥åšä»€ä¹ˆï¼Ÿ
}`,
                options: [
                    'new_node->next = NULL; head = new_node;',
                    'new_node->next = head; head = new_node;',
                    'head->next = new_node; new_node->next = NULL;',
                    'head = new_node; new_node->next = head;'
                ],
                correct: 1,
                explanation: 'æ­£ç¡®æ­¥éª¤ï¼š1) new_node->next = headï¼ˆæ–°èŠ‚ç‚¹æŒ‡å‘åŸå¤´èŠ‚ç‚¹ï¼‰2) head = new_nodeï¼ˆæ›´æ–°å¤´æŒ‡é’ˆï¼‰'
            },
            {
                type: 'medium',
                question: 'è¿™ä¸ªå‡½æ•°çš„æ—¶é—´å¤æ‚åº¦æ˜¯å¤šå°‘ï¼Ÿ',
                code: `void print_list(struct Node* head) {
    while (head != NULL) {
        printf("%d ", head->data);
        head = head->next;
    }
}`,
                options: [
                    'O(1)',
                    'O(log n)',
                    'O(n)',
                    'O(nÂ²)'
                ],
                correct: 2,
                explanation: 'å‡½æ•°éœ€è¦éå†é“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹ä¸€æ¬¡ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦æ˜¯O(n)ï¼Œå…¶ä¸­næ˜¯èŠ‚ç‚¹æ•°ã€‚'
            },
            {
                type: 'medium',
                question: 'åˆ é™¤é“¾è¡¨ä¸­ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„æ­£ç¡®æ–¹æ³•æ˜¯ä»€ä¹ˆï¼Ÿ',
                code: `struct Node* delete_head(struct Node* head) {
    if (head == NULL) return NULL;
    
    // æ­£ç¡®çš„åˆ é™¤æ­¥éª¤æ˜¯ä»€ä¹ˆï¼Ÿ
}`,
                options: [
                    'free(head); return NULL;',
                    'struct Node* temp = head; head = head->next; free(temp); return head;',
                    'head = head->next; return head;',
                    'head->data = 0; return head;'
                ],
                correct: 1,
                explanation: 'æ­£ç¡®æ­¥éª¤ï¼š1)ä¿å­˜å¤´èŠ‚ç‚¹ 2)æ›´æ–°å¤´æŒ‡é’ˆåˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ 3)é‡Šæ”¾åŸå¤´èŠ‚ç‚¹å†…å­˜ 4)è¿”å›æ–°å¤´æŒ‡é’ˆ'
            },
            {
                type: 'medium',
                question: 'è¿™æ®µä»£ç çš„é—®é¢˜æ˜¯ä»€ä¹ˆï¼Ÿ',
                code: `struct Node* head = NULL;
for (int i = 0; i < 5; i++) {
    struct Node* new_node = malloc(sizeof(struct Node));
    new_node->data = i;
    new_node->next = head;
    // å¿˜è®°æ›´æ–°headæŒ‡é’ˆ
}`,
                options: [
                    'å†…å­˜æ³„æ¼',
                    'headä»ç„¶æ˜¯NULL',
                    'åˆ›å»ºäº†5ä¸ªç‹¬ç«‹èŠ‚ç‚¹',
                    'ä»¥ä¸Šéƒ½å¯¹'
                ],
                correct: 3,
                explanation: 'æ²¡æœ‰æ›´æ–°headæŒ‡é’ˆï¼Œå¯¼è‡´ï¼š1)headä»ä¸ºNULL 2)åˆ›å»ºäº†5ä¸ªç‹¬ç«‹èŠ‚ç‚¹ 3)é™¤ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å¤–éƒ½æ— æ³•è®¿é—®ï¼Œé€ æˆå†…å­˜æ³„æ¼'
            },
            {
                type: 'medium',
                question: 'å¦‚ä½•å®‰å…¨åœ°éå†å¹¶åˆ é™¤é“¾è¡¨ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Ÿ',
                code: `void free_list(struct Node* head) {
    while (head != NULL) {
        // å®‰å…¨çš„åˆ é™¤æ–¹æ³•ï¼Ÿ
    }
}`,
                options: [
                    'free(head); head = head->next;',
                    'struct Node* temp = head; head = head->next; free(temp);',
                    'head = head->next; free(head);',
                    'free(head->next); head = head->next;'
                ],
                correct: 1,
                explanation: 'å¿…é¡»å…ˆä¿å­˜å½“å‰èŠ‚ç‚¹ï¼Œç„¶åç§»åŠ¨headæŒ‡é’ˆï¼Œæœ€åé‡Šæ”¾ä¿å­˜çš„èŠ‚ç‚¹ï¼Œé¿å…é‡Šæ”¾åå†è®¿é—®ã€‚'
            },
            {
                type: 'medium',
                question: 'è¿™ä¸ªå‡½æ•°æ£€æŸ¥ä»€ä¹ˆï¼Ÿ',
                code: `bool is_sorted(struct Node* head) {
    while (head != NULL && head->next != NULL) {
        if (head->data > head->next->data)
            return false;
        head = head->next;
    }
    return true;
}`,
                options: [
                    'é“¾è¡¨æ˜¯å¦ä¸ºç©º',
                    'é“¾è¡¨æ˜¯å¦æœ‰é‡å¤å…ƒç´ ',
                    'é“¾è¡¨æ˜¯å¦æŒ‰å‡åºæ’åˆ—',
                    'é“¾è¡¨æ˜¯å¦æœ‰ç¯'
                ],
                correct: 2,
                explanation: 'å‡½æ•°æ£€æŸ¥æ¯ä¸ªèŠ‚ç‚¹çš„æ•°æ®æ˜¯å¦å°äºç­‰äºä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æ•°æ®ï¼Œåˆ¤æ–­é“¾è¡¨æ˜¯å¦æŒ‰å‡åºæ’åˆ—ã€‚'
            },
            {
                type: 'medium',
                question: 'åˆå¹¶ä¸¤ä¸ªå·²æ’åºé“¾è¡¨çš„å…³é”®æ­¥éª¤æ˜¯ä»€ä¹ˆï¼Ÿ',
                code: `struct Node* merge_lists(struct Node* list1, struct Node* list2) {
    // å¦‚ä½•åˆå¹¶ä¸¤ä¸ªå·²æ’åºçš„é“¾è¡¨ï¼Ÿ
}`,
                options: [
                    'ç›´æ¥è¿æ¥ä¸¤ä¸ªé“¾è¡¨',
                    'æ¯”è¾ƒèŠ‚ç‚¹å€¼ï¼Œé€‰æ‹©è¾ƒå°çš„èŠ‚ç‚¹',
                    'é‡æ–°åˆ†é…æ‰€æœ‰èŠ‚ç‚¹',
                    'å…ˆæ’åºå†åˆå¹¶'
                ],
                correct: 1,
                explanation: 'åˆå¹¶å·²æ’åºé“¾è¡¨çš„å…³é”®æ˜¯æ¯”è¾ƒä¸¤ä¸ªé“¾è¡¨å½“å‰èŠ‚ç‚¹çš„å€¼ï¼Œé€‰æ‹©è¾ƒå°çš„èŠ‚ç‚¹æ·»åŠ åˆ°ç»“æœé“¾è¡¨ä¸­ã€‚'
            },
            {
                type: 'medium',
                question: 'è¿™æ®µä»£ç å®ç°äº†ä»€ä¹ˆåŠŸèƒ½ï¼Ÿ',
                code: `struct Node* remove_duplicates(struct Node* head) {
    struct Node* current = head;
    while (current != NULL && current->next != NULL) {
        if (current->data == current->next->data) {
            struct Node* temp = current->next;
            current->next = current->next->next;
            free(temp);
        } else {
            current = current->next;
        }
    }
    return head;
}`,
                options: [
                    'åˆ é™¤æ‰€æœ‰èŠ‚ç‚¹',
                    'åˆ é™¤é‡å¤èŠ‚ç‚¹',
                    'æ’åºé“¾è¡¨',
                    'åè½¬é“¾è¡¨'
                ],
                correct: 1,
                explanation: 'å‡½æ•°åˆ é™¤å·²æ’åºé“¾è¡¨ä¸­çš„é‡å¤èŠ‚ç‚¹ï¼Œä¿ç•™æ¯ä¸ªå€¼çš„ä¸€ä¸ªå‰¯æœ¬ã€‚'
            },

            // Hard Questions (10) - Interactive Simulators
            {
                type: 'hard',
                question: 'æ¨¡æ‹Ÿé“¾è¡¨æ’å…¥æ“ä½œï¼šç‚¹å‡»æŒ‰é’®åœ¨ä½ç½®2æ’å…¥å€¼ä¸º5çš„èŠ‚ç‚¹ï¼Œé“¾è¡¨å˜æˆä»€ä¹ˆæ ·ï¼Ÿ',
                interactive: true,
                initialState: [1, 3, 7],
                operation: 'insert',
                position: 2,
                value: 5,
                options: [
                    '[1, 3, 5, 7]',
                    '[1, 5, 3, 7]',
                    '[5, 1, 3, 7]',
                    '[1, 3, 7, 5]'
                ],
                correct: 0,
                explanation: 'åœ¨ä½ç½®2ï¼ˆä»0å¼€å§‹è®¡æ•°ï¼‰æ’å…¥èŠ‚ç‚¹5ï¼Œç»“æœä¸º[1, 3, 5, 7]ã€‚'
            },
            {
                type: 'hard',
                question: 'æ¨¡æ‹ŸæŒ‡é’ˆç§»åŠ¨ï¼šå½“å‰æŒ‡é’ˆæŒ‡å‘èŠ‚ç‚¹1ï¼Œç‚¹å‡»"ç§»åŠ¨2æ­¥"åæŒ‡å‘å“ªé‡Œï¼Ÿ',
                interactive: true,
                initialState: [10, 20, 30, 40],
                operation: 'move_pointer',
                steps: 2,
                options: [
                    'èŠ‚ç‚¹10',
                    'èŠ‚ç‚¹20',
                    'èŠ‚ç‚¹30',
                    'èŠ‚ç‚¹40'
                ],
                correct: 2,
                explanation: 'ä»èŠ‚ç‚¹10å¼€å§‹ï¼Œç§»åŠ¨2æ­¥ï¼š10â†’20â†’30ï¼Œæœ€ç»ˆæŒ‡å‘èŠ‚ç‚¹30ã€‚'
            },
            {
                type: 'hard',
                question: 'æ¨¡æ‹Ÿåˆ é™¤æ“ä½œï¼šåˆ é™¤é“¾è¡¨ä¸­å€¼ä¸º20çš„èŠ‚ç‚¹åï¼Œé“¾è¡¨ç»“æ„å¦‚ä½•ï¼Ÿ',
                interactive: true,
                initialState: [10, 20, 30, 20, 40],
                operation: 'delete_value',
                value: 20,
                options: [
                    '[10, 30, 40]',
                    '[10, 30, 20, 40]',
                    '[20, 30, 20, 40]',
                    '[10, 30, 40, 20]'
                ],
                correct: 0,
                explanation: 'åˆ é™¤æ‰€æœ‰å€¼ä¸º20çš„èŠ‚ç‚¹ï¼Œå‰©ä½™[10, 30, 40]ã€‚'
            },
            {
                type: 'hard',
                question: 'æ¨¡æ‹Ÿåè½¬æ“ä½œï¼šåè½¬é“¾è¡¨[A, B, C]åçš„ç»“æœæ˜¯ä»€ä¹ˆï¼Ÿ',
                interactive: true,
                initialState: ['A', 'B', 'C'],
                operation: 'reverse',
                options: [
                    '[A, B, C]',
                    '[C, B, A]',
                    '[B, A, C]',
                    '[A, C, B]'
                ],
                correct: 1,
                explanation: 'åè½¬é“¾è¡¨åï¼ŒèŠ‚ç‚¹é¡ºåºå®Œå…¨ç›¸åï¼š[A, B, C] â†’ [C, B, A]ã€‚'
            },
            {
                type: 'hard',
                question: 'æ¨¡æ‹Ÿç¯æ£€æµ‹ï¼šåœ¨èŠ‚ç‚¹Cå’ŒèŠ‚ç‚¹Aä¹‹é—´æ·»åŠ è¿æ¥ï¼Œå½¢æˆç¯åä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ',
                interactive: true,
                initialState: ['A', 'B', 'C'],
                operation: 'create_cycle',
                cycleConnection: 'C->A',
                options: [
                    'å¿«æ…¢æŒ‡é’ˆæ°¸ä¸ç›¸é‡',
                    'å¿«æ…¢æŒ‡é’ˆåœ¨èŠ‚ç‚¹Aç›¸é‡',
                    'å¿«æ…¢æŒ‡é’ˆåœ¨èŠ‚ç‚¹Bç›¸é‡',
                    'ç¨‹åºå´©æºƒ'
                ],
                correct: 1,
                explanation: 'å½¢æˆç¯Aâ†’Bâ†’Câ†’Aåï¼Œå¿«æ…¢æŒ‡é’ˆæœ€ç»ˆä¼šåœ¨ç¯ä¸­çš„æŸç‚¹ç›¸é‡ï¼Œè¿™é‡Œæ˜¯èŠ‚ç‚¹Aã€‚'
            },
            {
                type: 'hard',
                question: 'æ¨¡æ‹Ÿåˆå¹¶æ“ä½œï¼šåˆå¹¶é“¾è¡¨[1,3,5]å’Œ[2,4,6]çš„æ­¥éª¤æ˜¯ä»€ä¹ˆï¼Ÿ',
                interactive: true,
                initialState: { list1: [1, 3, 5], list2: [2, 4, 6] },
                operation: 'merge_sorted',
                options: [
                    '[1,2,3,4,5,6]',
                    '[1,3,5,2,4,6]',
                    '[2,4,6,1,3,5]',
                    '[1,3,2,4,5,6]'
                ],
                correct: 0,
                explanation: 'åˆå¹¶ä¸¤ä¸ªå·²æ’åºé“¾è¡¨ï¼Œé€ä¸ªæ¯”è¾ƒå¹¶é€‰æ‹©è¾ƒå°å€¼ï¼š1,2,3,4,5,6ã€‚'
            },
            {
                type: 'hard',
                question: 'æ¨¡æ‹ŸæŸ¥æ‰¾æ“ä½œï¼šåœ¨é“¾è¡¨ä¸­æŸ¥æ‰¾å€¼ä¸º7ï¼ŒæŒ‡é’ˆç§»åŠ¨äº†å‡ æ¬¡ï¼Ÿ',
                interactive: true,
                initialState: [3, 7, 12, 7, 15],
                operation: 'search',
                target: 7,
                options: [
                    '1æ¬¡',
                    '2æ¬¡',
                    '3æ¬¡',
                    '4æ¬¡'
                ],
                correct: 1,
                explanation: 'ä»å¤´å¼€å§‹æŸ¥æ‰¾ï¼š3(1æ¬¡ç§»åŠ¨)â†’7(æ‰¾åˆ°)ï¼Œæ€»å…±ç§»åŠ¨1æ¬¡ã€‚ä½†æŒ‡é’ˆç§»åŠ¨æ¬¡æ•°åŒ…æ‹¬åˆå§‹ä½ç½®ï¼Œæ‰€ä»¥æ˜¯2æ¬¡ã€‚'
            },
            {
                type: 'hard',
                question: 'æ¨¡æ‹Ÿæ’åºæ“ä½œï¼šå¯¹é“¾è¡¨[3,1,4,2]è¿›è¡Œå†’æ³¡æ’åºï¼Œç¬¬ä¸€è½®åçš„ç»“æœï¼Ÿ',
                interactive: true,
                initialState: [3, 1, 4, 2],
                operation: 'bubble_sort_step',
                round: 1,
                options: [
                    '[1,3,2,4]',
                    '[1,3,4,2]',
                    '[3,1,2,4]',
                    '[1,2,3,4]'
                ],
                correct: 0,
                explanation: 'ç¬¬ä¸€è½®å†’æ³¡æ’åºï¼šæ¯”è¾ƒç›¸é‚»å…ƒç´ å¹¶äº¤æ¢ï¼Œæœ€å¤§å€¼4ç§»åˆ°æœ«å°¾ï¼Œç»“æœ[1,3,2,4]ã€‚'
            },
            {
                type: 'hard',
                question: 'æ¨¡æ‹Ÿæ‹†åˆ†æ“ä½œï¼šå°†é“¾è¡¨[1,2,3,4,5,6]ä»ä¸­é—´æ‹†åˆ†ï¼Œç»“æœæ˜¯ä»€ä¹ˆï¼Ÿ',
                interactive: true,
                initialState: [1, 2, 3, 4, 5, 6],
                operation: 'split_middle',
                options: [
                    '[1,2,3] å’Œ [4,5,6]',
                    '[1,2] å’Œ [3,4,5,6]',
                    '[1,2,3,4] å’Œ [5,6]',
                    '[1] å’Œ [2,3,4,5,6]'
                ],
                correct: 0,
                explanation: 'ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°ä¸­ç‚¹ï¼Œåœ¨ä¸­é—´æ‹†åˆ†ï¼š[1,2,3]å’Œ[4,5,6]ã€‚'
            },
            {
                type: 'hard',
                question: 'æ¨¡æ‹Ÿé€’å½’éå†ï¼šé€’å½’æ‰“å°é“¾è¡¨[A,B,C]ï¼Œè°ƒç”¨æ ˆçš„æ·±åº¦æ˜¯å¤šå°‘ï¼Ÿ',
                interactive: true,
                initialState: ['A', 'B', 'C'],
                operation: 'recursive_print',
                options: [
                    '1',
                    '2',
                    '3',
                    '4'
                ],
                correct: 3,
                explanation: 'é€’å½’è°ƒç”¨ï¼šprint(A)â†’print(B)â†’print(C)â†’print(NULL)ï¼Œæœ€å¤§è°ƒç”¨æ ˆæ·±åº¦ä¸º4ã€‚'
            },

            // Extreme Questions (5) - Programming with Compilation Simulation
            {
                type: 'extreme',
                question: 'å®ç°é“¾è¡¨å¤´éƒ¨æ’å…¥å‡½æ•°ï¼šå®Œæˆä»¥ä¸‹å‡½æ•°ï¼Œåœ¨é“¾è¡¨å¤´éƒ¨æ’å…¥æ–°èŠ‚ç‚¹ã€‚',
                template: `struct Node* insert_at_head(struct Node* head, int data) {
    // åœ¨è¿™é‡Œå†™ä»£ç 
    /* 
     * æç¤ºï¼š
     * 1. åˆ†é…æ–°èŠ‚ç‚¹å†…å­˜
     * 2. è®¾ç½®èŠ‚ç‚¹æ•°æ®
     * 3. è®¾ç½®èŠ‚ç‚¹æŒ‡é’ˆ
     * 4. è¿”å›æ–°çš„å¤´æŒ‡é’ˆ
     */
    
}`,
                correctKeywords: ['malloc', 'new_node', 'data', 'next', 'head', 'return'],
                testCases: [
                    { input: 'insert_at_head(NULL, 5)', expected: 'List: [5]' },
                    { input: 'insert_at_head([1,2], 0)', expected: 'List: [0,1,2]' }
                ],
                explanation: 'æ­£ç¡®å®ç°éœ€è¦ï¼šåˆ†é…å†…å­˜ã€è®¾ç½®æ•°æ®ã€è¿æ¥æŒ‡é’ˆã€è¿”å›æ–°å¤´èŠ‚ç‚¹ã€‚'
            },
            {
                type: 'extreme',
                question: 'å®ç°é“¾è¡¨åˆ é™¤å‡½æ•°ï¼šå®Œæˆä»¥ä¸‹å‡½æ•°ï¼Œåˆ é™¤é“¾è¡¨ä¸­ç¬¬ä¸€ä¸ªå€¼ä¸ºtargetçš„èŠ‚ç‚¹ã€‚',
                template: `struct Node* delete_node(struct Node* head, int target) {
    // åœ¨è¿™é‡Œå†™ä»£ç 
    /*
     * æç¤ºï¼š
     * 1. æ£€æŸ¥å¤´èŠ‚ç‚¹æ˜¯å¦ä¸ºç›®æ ‡
     * 2. éå†é“¾è¡¨æŸ¥æ‰¾ç›®æ ‡èŠ‚ç‚¹
     * 3. è°ƒæ•´æŒ‡é’ˆè¿æ¥
     * 4. é‡Šæ”¾èŠ‚ç‚¹å†…å­˜
     */
    
}`,
                correctKeywords: ['if', 'head', 'target', 'prev', 'current', 'free', 'return'],
                testCases: [
                    { input: 'delete_node([1,2,3], 2)', expected: 'List: [1,3]' },
                    { input: 'delete_node([5], 5)', expected: 'List: []' }
                ],
                explanation: 'éœ€è¦å¤„ç†åˆ é™¤å¤´èŠ‚ç‚¹å’Œä¸­é—´èŠ‚ç‚¹çš„ä¸åŒæƒ…å†µï¼Œå¹¶æ­£ç¡®é‡Šæ”¾å†…å­˜ã€‚'
            },
            {
                type: 'extreme',
                question: 'å®ç°é“¾è¡¨åè½¬å‡½æ•°ï¼šå®Œæˆä»¥ä¸‹å‡½æ•°ï¼Œåè½¬æ•´ä¸ªé“¾è¡¨ã€‚',
                template: `struct Node* reverse_list(struct Node* head) {
    // åœ¨è¿™é‡Œå†™ä»£ç 
    /*
     * æç¤ºï¼š
     * 1. ä½¿ç”¨ä¸‰ä¸ªæŒ‡é’ˆï¼šprev, current, next
     * 2. éå†é“¾è¡¨å¹¶åè½¬æ¯ä¸ªæŒ‡é’ˆ
     * 3. è¿”å›æ–°çš„å¤´æŒ‡é’ˆ
     */
    
}`,
                correctKeywords: ['prev', 'current', 'next', 'while', 'NULL', 'return'],
                testCases: [
                    { input: 'reverse_list([1,2,3])', expected: 'List: [3,2,1]' },
                    { input: 'reverse_list([5])', expected: 'List: [5]' }
                ],
                explanation: 'é“¾è¡¨åè½¬çš„ç»å…¸ä¸‰æŒ‡é’ˆç®—æ³•ï¼šä¿å­˜ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œåè½¬å½“å‰æŒ‡é’ˆï¼Œç§»åŠ¨æ‰€æœ‰æŒ‡é’ˆã€‚'
            },
            {
                type: 'extreme',
                question: 'å®ç°é“¾è¡¨åˆå¹¶å‡½æ•°ï¼šåˆå¹¶ä¸¤ä¸ªå·²æ’åºçš„é“¾è¡¨ã€‚',
                template: `struct Node* merge_sorted_lists(struct Node* list1, struct Node* list2) {
    // åœ¨è¿™é‡Œå†™ä»£ç 
    /*
     * æç¤ºï¼š
     * 1. åˆ›å»ºè™šæ‹Ÿå¤´èŠ‚ç‚¹
     * 2. æ¯”è¾ƒä¸¤ä¸ªé“¾è¡¨çš„å½“å‰èŠ‚ç‚¹
     * 3. è¿æ¥è¾ƒå°çš„èŠ‚ç‚¹
     * 4. å¤„ç†å‰©ä½™èŠ‚ç‚¹
     */
    
}`,
                correctKeywords: ['dummy', 'current', 'list1', 'list2', 'data', 'next', 'while'],
                testCases: [
                    { input: 'merge_sorted_lists([1,3,5], [2,4,6])', expected: 'List: [1,2,3,4,5,6]' },
                    { input: 'merge_sorted_lists([1], [2])', expected: 'List: [1,2]' }
                ],
                explanation: 'åˆå¹¶å·²æ’åºé“¾è¡¨éœ€è¦é€ä¸ªæ¯”è¾ƒèŠ‚ç‚¹å€¼ï¼Œé€‰æ‹©è¾ƒå°çš„èŠ‚ç‚¹åŠ å…¥ç»“æœé“¾è¡¨ã€‚'
            },
            {
                type: 'extreme',
                question: 'å®ç°ç¯æ£€æµ‹å‡½æ•°ï¼šæ£€æµ‹é“¾è¡¨æ˜¯å¦åŒ…å«ç¯ã€‚',
                template: `bool has_cycle(struct Node* head) {
    // åœ¨è¿™é‡Œå†™ä»£ç 
    /*
     * æç¤ºï¼š
     * 1. ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼ˆFloydç®—æ³•ï¼‰
     * 2. æ…¢æŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨1æ­¥
     * 3. å¿«æŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨2æ­¥
     * 4. å¦‚æœæœ‰ç¯ï¼Œå¿«æ…¢æŒ‡é’ˆä¼šç›¸é‡
     */
    
}`,
                correctKeywords: ['slow', 'fast', 'while', 'next', 'if', 'return', 'true', 'false'],
                testCases: [
                    { input: 'has_cycle([1,2,3])', expected: 'false' },
                    { input: 'has_cycle([1,2,3] with 3->1)', expected: 'true' }
                ],
                explanation: 'Floydåˆ¤åœˆç®—æ³•ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ£€æµ‹ç¯ï¼šå¦‚æœå­˜åœ¨ç¯ï¼Œå¿«æŒ‡é’ˆæœ€ç»ˆä¼šè¿½ä¸Šæ…¢æŒ‡é’ˆã€‚'
            }
        ];

        function displayQuestion(index) {
            const question = questions[index];
            const container = document.getElementById('quizContainer');
            
            let difficultyClass = '';
            let difficultyText = '';
            
            switch(question.type) {
                case 'easy':
                    difficultyClass = 'difficulty-easy';
                    difficultyText = 'ç®€å•';
                    break;
                case 'medium':
                    difficultyClass = 'difficulty-medium';
                    difficultyText = 'æ™®é€š';
                    break;
                case 'hard':
                    difficultyClass = 'difficulty-hard';
                    difficultyText = 'å›°éš¾';
                    break;
                case 'extreme':
                    difficultyClass = 'difficulty-extreme';
                    difficultyText = 'è¶…éš¾';
                    break;
            }

            let questionContent = '';
            
            if (question.type === 'extreme') {
                // Programming question with code editor
                questionContent = `
                    <div class="question-card" id="question-${index}">
                        <div class="difficulty-badge ${difficultyClass}">${difficultyText}</div>
                        <h3 class="text-lg font-bold mb-3">é—®é¢˜ ${index + 1}: ${question.question}</h3>
                        
                        <div class="code-block">${question.template}</div>
                        
                        <textarea class="code-editor" id="code-${index}" placeholder="åœ¨è¿™é‡Œç¼–å†™æ‚¨çš„ä»£ç ..."></textarea>
                        
                        <button class="compile-button" onclick="simulateCompilation(${index})">
                            ğŸ”¨ æ¨¡æ‹Ÿç¼–è¯‘ä¸è¿è¡Œ
                        </button>
                        
                        <div class="compile-output" id="output-${index}"></div>
                        
                        <div class="mt-4">
                            ${question.options.map((option, i) => 
                                `<button class="option-button" id="option-${index}-${i}" onclick="selectAnswer(${index}, ${i})">
                                    ${String.fromCharCode(65 + i)}. ${option}
                                </button>`
                            ).join('')}
                        </div>
                        
                        <div class="explanation" id="explanation-${index}">
                            <strong>è§£é‡Šï¼š</strong> ${question.explanation}
                        </div>
                    </div>
                `;
            } else if (question.interactive) {
                // Interactive simulator question
                questionContent = `
                    <div class="question-card" id="question-${index}">
                        <div class="difficulty-badge ${difficultyClass}">${difficultyText}</div>
                        <h3 class="text-lg font-bold mb-3">é—®é¢˜ ${index + 1}: ${question.question}</h3>
                        
                        <div class="interactive-simulator" id="simulator-${index}">
                            <div class="mb-4">
                                <strong>åˆå§‹é“¾è¡¨ï¼š</strong>
                                <div id="list-display-${index}" class="mt-2"></div>
                            </div>
                            <button class="simulator-button" onclick="runSimulation(${index})">
                                è¿è¡Œæ¨¡æ‹Ÿ
                            </button>
                            <div id="simulation-result-${index}" class="mt-4"></div>
                        </div>
                        
                        <div class="mt-4">
                            ${question.options.map((option, i) => 
                                `<button class="option-button" id="option-${index}-${i}" onclick="selectAnswer(${index}, ${i})">
                                    ${String.fromCharCode(65 + i)}. ${option}
                                </button>`
                            ).join('')}
                        </div>
                        
                        <div class="explanation" id="explanation-${index}">
                            <strong>è§£é‡Šï¼š</strong> ${question.explanation}
                        </div>
                    </div>
                `;
            } else {
                // Regular question (easy/medium)
                questionContent = `
                    <div class="question-card" id="question-${index}">
                        <div class="difficulty-badge ${difficultyClass}">${difficultyText}</div>
                        <h3 class="text-lg font-bold mb-3">é—®é¢˜ ${index + 1}: ${question.question}</h3>
                        
                        ${question.code ? `<div class="code-block">${question.code}</div>` : ''}
                        
                        <div class="mt-4">
                            ${question.options.map((option, i) => 
                                `<button class="option-button" id="option-${index}-${i}" onclick="selectAnswer(${index}, ${i})">
                                    ${String.fromCharCode(65 + i)}. ${option}
                                </button>`
                            ).join('')}
                        </div>
                        
                        <div class="explanation" id="explanation-${index}">
                            <strong>è§£é‡Šï¼š</strong> ${question.explanation}
                        </div>
                    </div>
                `;
            }
            
            container.innerHTML += questionContent;

            // Initialize interactive elements
            if (question.interactive) {
                initializeSimulator(index);
            }
        }

        function initializeSimulator(index) {
            const question = questions[index];
            const displayElement = document.getElementById(`list-display-${index}`);
            
            if (Array.isArray(question.initialState)) {
                const nodesHTML = question.initialState.map(item => 
                    `<div class="node-visual">
                        <div class="node-data">${item}</div>
                        <div class="node-pointer">â†’</div>
                    </div>`
                ).join('');
                
                displayElement.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; flex-wrap: wrap; gap: 0.5rem;">
                        ${nodesHTML}
                        <span style="color: #888; font-family: 'Courier New', monospace;">NULL</span>
                    </div>
                    <div style="margin-top: 1rem; text-align: center; color: #666; font-size: 0.9rem;">
                        åˆå§‹é“¾è¡¨ï¼š${question.initialState.join(' â†’ ')} â†’ NULL
                    </div>
                `;
            } else if (question.initialState && question.initialState.list1) {
                displayElement.innerHTML = `
                    <div style="margin-bottom: 1rem;">
                        <div style="margin-bottom: 0.5rem;"><strong>é“¾è¡¨1:</strong> 
                            <span style="font-family: 'Courier New', monospace; color: #e07a5f;">${question.initialState.list1.join(' â†’ ')} â†’ NULL</span>
                        </div>
                        <div><strong>é“¾è¡¨2:</strong> 
                            <span style="font-family: 'Courier New', monospace; color: #e07a5f;">${question.initialState.list2.join(' â†’ ')} â†’ NULL</span>
                        </div>
                    </div>
                `;
            } else {
                displayElement.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: #666;">
                        <div style="font-size: 1.2rem; margin-bottom: 1rem;">ğŸ”— é“¾è¡¨æ¨¡æ‹Ÿå™¨</div>
                        <div>ç‚¹å‡»"è¿è¡Œæ¨¡æ‹Ÿ"æŒ‰é’®æŸ¥çœ‹é“¾è¡¨æ“ä½œçš„å¯è§†åŒ–è¿‡ç¨‹</div>
                    </div>
                `;
            }
        }

        function runSimulation(index) {
            const question = questions[index];
            const resultElement = document.getElementById(`simulation-result-${index}`);
            const button = document.querySelector(`#simulator-${index} .simulator-button`);
            
            button.disabled = true;
            button.textContent = 'è¿è¡Œä¸­...';
            
            setTimeout(() => {
                let result = '';
                let resultStyle = '';
                
                switch(question.operation) {
                    case 'insert':
                        result = `
                            <strong>ğŸ”— é“¾è¡¨æ’å…¥æ¨¡æ‹Ÿå®Œæˆï¼</strong><br>
                            â€¢ åœ¨ä½ç½®${question.position}æ’å…¥å€¼${question.value}<br>
                            â€¢ æ–°é“¾è¡¨ï¼š${question.options[question.correct]}<br>
                            â€¢ æ’å…¥æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ï¼šO(n)
                        `;
                        resultStyle = 'background-color: #f0fdf4; padding: 1rem; border-radius: 0.5rem; border-left: 4px solid #22c55e;';
                        break;
                    case 'move_pointer':
                        result = `
                            <strong>ğŸ”„ æŒ‡é’ˆç§»åŠ¨æ¨¡æ‹Ÿå®Œæˆï¼</strong><br>
                            â€¢ ä»èµ·å§‹ä½ç½®ç§»åŠ¨${question.steps}æ­¥<br>
                            â€¢ æœ€ç»ˆæŒ‡å‘ï¼š${question.options[question.correct]}<br>
                            â€¢ é“¾è¡¨éå†çš„æ—¶é—´å¤æ‚åº¦ï¼šO(n)
                        `;
                        resultStyle = 'background-color: #fefce8; padding: 1rem; border-radius: 0.5rem; border-left: 4px solid #f59e0b;';
                        break;
                    case 'delete_value':
                        result = `
                            <strong>âŒ é“¾è¡¨åˆ é™¤æ¨¡æ‹Ÿå®Œæˆï¼</strong><br>
                            â€¢ åˆ é™¤æ‰€æœ‰å€¼ä¸º${question.value}çš„èŠ‚ç‚¹<br>
                            â€¢ ç»“æœé“¾è¡¨ï¼š${question.options[question.correct]}<br>
                            â€¢ è®°å¾—é‡Šæ”¾è¢«åˆ é™¤èŠ‚ç‚¹çš„å†…å­˜
                        `;
                        resultStyle = 'background-color: #fef2f2; padding: 1rem; border-radius: 0.5rem; border-left: 4px solid #ef4444;';
                        break;
                    case 'reverse':
                        result = `
                            <strong>ğŸ” é“¾è¡¨åè½¬æ¨¡æ‹Ÿå®Œæˆï¼</strong><br>
                            â€¢ ä½¿ç”¨ä¸‰æŒ‡é’ˆç®—æ³•åè½¬é“¾è¡¨<br>
                            â€¢ åè½¬åé“¾è¡¨ï¼š${question.options[question.correct]}<br>
                            â€¢ æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œç©ºé—´å¤æ‚åº¦ï¼šO(1)
                        `;
                        resultStyle = 'background-color: #f3e8ff; padding: 1rem; border-radius: 0.5rem; border-left: 4px solid #a855f7;';
                        break;
                    case 'merge_sorted':
                        result = `
                            <strong>ğŸ”„ é“¾è¡¨åˆå¹¶æ¨¡æ‹Ÿå®Œæˆï¼</strong><br>
                            â€¢ åˆå¹¶ä¸¤ä¸ªå·²æ’åºé“¾è¡¨<br>
                            â€¢ åˆå¹¶ç»“æœï¼š${question.options[question.correct]}<br>
                            â€¢ æ¯”è¾ƒèŠ‚ç‚¹å€¼ï¼Œé€‰æ‹©è¾ƒå°çš„åŠ å…¥ç»“æœ
                        `;
                        resultStyle = 'background-color: #e0f2fe; padding: 1rem; border-radius: 0.5rem; border-left: 4px solid #0ea5e9;';
                        break;
                    default:
                        result = `
                            <strong>âœ… é“¾è¡¨æ“ä½œæ¨¡æ‹Ÿå®Œæˆï¼</strong><br>
                            â€¢ æ“ä½œç»“æœï¼š${question.options[question.correct]}<br>
                            â€¢ ç†è§£é“¾è¡¨æ“ä½œçš„åŸºæœ¬åŸç†å’Œæ—¶é—´å¤æ‚åº¦
                        `;
                        resultStyle = 'background-color: #f0fdf4; padding: 1rem; border-radius: 0.5rem; border-left: 4px solid #22c55e;';
                }
                
                resultElement.innerHTML = `<div style="${resultStyle}">${result}</div>`;
                
                button.textContent = 'é‡æ–°è¿è¡Œ';
                button.disabled = false;
            }, 1500);
        }

        function simulateCompilation(index) {
            const question = questions[index];
            const code = document.getElementById(`code-${index}`).value;
            const outputElement = document.getElementById(`output-${index}`);
            
            outputElement.classList.add('show');
            outputElement.innerHTML = '';
            
            const steps = [
                '> gcc student_code.c -o student_program',
                '> Compiling...',
                '> Syntax check...',
                '> Linking...',
                '> Running test cases...'
            ];
            
            let stepIndex = 0;
            const interval = setInterval(() => {
                outputElement.innerHTML += steps[stepIndex] + '\n';
                stepIndex++;
                
                if (stepIndex >= steps.length) {
                    clearInterval(interval);
                    
                    // Simple keyword checking
                    const hasRequiredKeywords = question.correctKeywords.some(keyword => 
                        code.toLowerCase().includes(keyword.toLowerCase())
                    );
                    
                    const keywordCount = question.correctKeywords.filter(keyword => 
                        code.toLowerCase().includes(keyword.toLowerCase())
                    ).length;
                    
                    let result = '';
                    if (keywordCount >= question.correctKeywords.length * 0.8) {
                        result = '> ç¼–è¯‘æˆåŠŸï¼\n> æ‰€æœ‰æµ‹è¯•ç”¨ä¾‹é€šè¿‡ï¼\n> ç»“æœï¼šå®Œå…¨æ­£ç¡® âœ…';
                    } else if (keywordCount >= question.correctKeywords.length * 0.5) {
                        result = '> ç¼–è¯‘æˆåŠŸï¼\n> éƒ¨åˆ†æµ‹è¯•ç”¨ä¾‹é€šè¿‡\n> ç»“æœï¼šéƒ¨åˆ†æ­£ç¡® âš ï¸';
                    } else {
                        result = '> ç¼–è¯‘å¤±è´¥ï¼\n> è¯­æ³•é”™è¯¯æˆ–é€»è¾‘é”™è¯¯\n> ç»“æœï¼šç¼–è¯‘å¤±è´¥ âŒ';
                    }
                    
                    setTimeout(() => {
                        outputElement.innerHTML += '\n' + result;
                    }, 1000);
                }
            }, 800);
        }

        function selectAnswer(questionIndex, selectedOption) {
            const question = questions[questionIndex];
            const questionCard = document.getElementById(`question-${questionIndex}`);
            const explanation = document.getElementById(`explanation-${questionIndex}`);
            
            // Disable all option buttons for this question
            for (let i = 0; i < question.options.length; i++) {
                const optionButton = document.getElementById(`option-${questionIndex}-${i}`);
                optionButton.classList.add('disabled');
                
                if (i === question.correct) {
                    optionButton.classList.add('correct');
                }
                if (i === selectedOption && i !== question.correct) {
                    optionButton.classList.add('incorrect');
                }
            }
            
            // Show explanation
            explanation.classList.add('show');
            
            // Update question card style and score
            if (selectedOption === question.correct) {
                questionCard.classList.add('answered-correct');
                correctAnswers++;
            } else {
                questionCard.classList.add('answered-incorrect');
                incorrectAnswers++;
            }
            
            updateScore();
            updateProgress();
            
            currentQuestion++;
        }

        function updateScore() {
            const totalAnswered = correctAnswers + incorrectAnswers;
            document.getElementById('scoreDisplay').textContent = `${correctAnswers}/${totalAnswered}`;
            document.getElementById('correctDisplay').textContent = correctAnswers;
            document.getElementById('incorrectDisplay').textContent = incorrectAnswers;
        }

        function updateProgress() {
            const totalAnswered = correctAnswers + incorrectAnswers;
            const progressPercentage = (totalAnswered / questions.length) * 100;
            document.getElementById('progressBar').style.width = `${progressPercentage}%`;
        }

        // Initialize quiz
        document.addEventListener('DOMContentLoaded', function() {
            questions.forEach((_, index) => {
                displayQuestion(index);
            });
            updateScore();
        });
    </script>
</body>
</html> 