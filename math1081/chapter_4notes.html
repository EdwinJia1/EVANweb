<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 4 - Logic and Truth Tables | Discrete Mathematics</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;
            background-color: #f8f7f2;
            color: #2c2c2c;
        }
        .home-button {
            background-color: #e07a5f;
            color: #f8f7f2;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s ease-in-out;
            display: inline-block;
        }
        .home-button:hover {
            background-color: #d06850;
            transform: translateY(-1px);
        }
        .concept-card {
            background-color: #ffffff;
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin-top: 1rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .math {
            font-family: "Cambria Math", "Times New Roman", serif;
            font-size: 1.1em;
            display: inline-block;
        }
        .chapter-title {
            font-size: 2.5rem;
            font-weight: 700;
            text-align: center;
            color: #2c2c2c;
            margin: 2rem 0;
        }
        .summary-card {
            background: linear-gradient(135deg, #f4a261 0%, #e76f51 100%);
            color: #ffffff;
            border-radius: 0.5rem;
            padding: 2rem;
            margin: 2rem 0;
            box-shadow: 0 8px 16px -4px rgb(0 0 0 / 0.1);
        }
        .notion-link {
            background-color: #2c2c2c;
            color: #f8f7f2;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s ease-in-out;
            display: inline-block;
            margin-top: 1rem;
        }
        .notion-link:hover {
            background-color: #1a1a1a;
            transform: translateY(-1px);
        }
        .logic-table {
            background-color: #f8f7f2;
            border-radius: 0.375rem;
            margin: 1rem 0;
            overflow-x: auto;
        }
        .logic-table table {
            width: 100%;
            border-collapse: collapse;
        }
        .logic-table th,
        .logic-table td {
            padding: 0.75rem;
            text-align: center;
            border: 1px solid #d1d5db;
        }
        .logic-table th {
            background-color: #e07a5f;
            color: #ffffff;
            font-weight: 600;
        }
        .logic-table td {
            background-color: #ffffff;
        }
        .logic-example {
            background-color: #fff7ed;
            border-left: 4px solid #f4a261;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 0.375rem 0.375rem 0;
        }
    </style>
</head>
<body class="antialiased">
    <div class="container mx-auto px-4 py-6 max-w-4xl">
        <!-- Header -->
        <header class="flex justify-between items-center mb-8">
            <a href="../index.html" class="home-button">â† Back to Home</a>
            <h1 class="chapter-title">Chapter 4 - Logic and Truth Tables</h1>
            <div class="w-24"></div> <!-- Spacer for centering -->
        </header>

        <!-- Chapter Summary -->
        <div class="summary-card">
            <h2 class="text-2xl font-bold mb-4">Chapter Summary</h2>
            <p class="text-lg leading-relaxed">
                This chapter covers <strong>Logic and Truth Tables</strong>, fundamental concepts in discrete mathematics 
                and computer science. We explore propositional logic, logical operators, truth tables, and logical 
                equivalences that form the foundation of mathematical reasoning and computer programming.
            </p>
            <div class="mt-4 grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
                <div>
                    <strong>Key Concepts:</strong>
                    <ul class="mt-1">
                        <li>â€¢ Propositional Logic</li>
                        <li>â€¢ Logical Operators</li>
                        <li>â€¢ Truth Tables</li>
                        <li>â€¢ Logical Equivalences</li>
                    </ul>
                </div>
                <div>
                    <strong>Learning Goals:</strong>
                    <ul class="mt-1">
                        <li>â€¢ Construct truth tables</li>
                        <li>â€¢ Apply logical operators</li>
                        <li>â€¢ Prove logical equivalences</li>
                        <li>â€¢ Analyze logical arguments</li>
                    </ul>
                </div>
                <div>
                    <strong>Prerequisites:</strong>
                    <ul class="mt-1">
                        <li>â€¢ Basic set theory</li>
                        <li>â€¢ Mathematical reasoning</li>
                        <li>â€¢ Chapter 1 concepts</li>
                        <li>â€¢ Boolean operations</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Content Notice -->
        <div class="concept-card text-center">
            <h3 class="text-xl font-bold text-[#e07a5f] mb-3">æœ€æ–°å†…å®¹</h3>
            <p class="text-gray-600 mb-4">
                ç¬¬å››ç« å†…å®¹æ­£åœ¨æŒç»­æ›´æ–°ä¸­ã€‚è¦è·å–æœ€æ–°ã€æœ€å®Œæ•´çš„å†…å®¹ï¼Œ
                è¯·è®¿é—®ä¸‹æ–¹çš„Notioné¡µé¢ï¼Œé‚£é‡Œæœ‰å®æ—¶æ›´æ–°çš„ç¬”è®°å’Œæœ€æ–°ææ–™ã€‚
            </p>
            <a href="https://fishy-cloche-56b.notion.site/Chapter-4-Logic-and-Truth-Tables-22298e94886480fda6e8cce570f8800d?pvs=73" 
               target="_blank" 
               rel="noopener noreferrer" 
               class="notion-link">
                æŸ¥çœ‹Notionä¸­çš„ç¬¬å››ç« æœ€æ–°å†…å®¹ â†—
            </a>
        </div>

        <!-- Basic Logic Concepts -->
        <div class="concept-card">
            <h3 class="text-xl font-bold text-[#e07a5f] mb-3">åŸºç¡€é€»è¾‘æ¦‚å¿µ</h3>
            <p class="text-gray-600 mb-4">
                å‘½é¢˜é€»è¾‘æ˜¯ç¦»æ•£æ•°å­¦çš„åŸºç¡€ï¼Œå®ƒç ”ç©¶å‘½é¢˜ï¼ˆå¯ä»¥åˆ¤æ–­çœŸå‡çš„é™ˆè¿°ï¼‰ä¹‹é—´çš„é€»è¾‘å…³ç³»ã€‚
            </p>
            
            <div class="logic-example">
                <h4 class="font-bold text-[#f4a261] mb-2">ä»€ä¹ˆæ˜¯å‘½é¢˜ï¼Ÿ</h4>
                <p class="mb-2">å‘½é¢˜æ˜¯ä¸€ä¸ªå¯ä»¥æ˜ç¡®åˆ¤æ–­ä¸ºçœŸï¼ˆTï¼‰æˆ–å‡ï¼ˆFï¼‰çš„é™ˆè¿°ã€‚</p>
                <p class="text-sm text-gray-600">
                    <strong>å‘½é¢˜ç¤ºä¾‹ï¼š</strong> "ä»Šå¤©æ˜¯æ˜ŸæœŸä¸€"ï¼ˆå¯ä»¥æ˜¯çœŸæˆ–å‡ï¼‰<br>
                    <strong>éå‘½é¢˜ç¤ºä¾‹ï¼š</strong> "ä»Šå¤©å¤©æ°”å¥½å—ï¼Ÿ"ï¼ˆç–‘é—®å¥ï¼Œæ— æ³•åˆ¤æ–­çœŸå‡ï¼‰
                </p>
            </div>
        </div>

        <!-- Logical Operators -->
        <div class="concept-card">
            <h3 class="text-xl font-bold text-[#e07a5f] mb-3">é€»è¾‘è¿ç®—ç¬¦</h3>
            <p class="text-gray-600 mb-4">
                é€»è¾‘è¿ç®—ç¬¦ç”¨äºç»„åˆç®€å•å‘½é¢˜å½¢æˆå¤åˆå‘½é¢˜ã€‚ä»¥ä¸‹æ˜¯ä¸»è¦çš„é€»è¾‘è¿ç®—ç¬¦ï¼š
            </p>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div class="logic-example">
                    <h4 class="font-bold text-[#f4a261] mb-2">å¦å®š (NOT) - Â¬</h4>
                    <p class="text-sm">å¦‚æœ p ä¸ºçœŸï¼Œåˆ™ Â¬p ä¸ºå‡ï¼›å¦‚æœ p ä¸ºå‡ï¼Œåˆ™ Â¬p ä¸ºçœŸã€‚</p>
                </div>
                
                <div class="logic-example">
                    <h4 class="font-bold text-[#f4a261] mb-2">åˆå– (AND) - âˆ§</h4>
                    <p class="text-sm">åªæœ‰å½“ p å’Œ q éƒ½ä¸ºçœŸæ—¶ï¼Œp âˆ§ q æ‰ä¸ºçœŸã€‚</p>
                </div>
                
                <div class="logic-example">
                    <h4 class="font-bold text-[#f4a261] mb-2">æå– (OR) - âˆ¨</h4>
                    <p class="text-sm">å½“ p æˆ– q ä¸­è‡³å°‘æœ‰ä¸€ä¸ªä¸ºçœŸæ—¶ï¼Œp âˆ¨ q ä¸ºçœŸã€‚</p>
                </div>
                
                <div class="logic-example">
                    <h4 class="font-bold text-[#f4a261] mb-2">è•´å« (IMPLIES) - â†’</h4>
                    <p class="text-sm">åªæœ‰å½“ p ä¸ºçœŸä¸” q ä¸ºå‡æ—¶ï¼Œp â†’ q æ‰ä¸ºå‡ã€‚</p>
                </div>
            </div>
        </div>

        <!-- Truth Table Example -->
        <div class="concept-card">
            <h3 class="text-xl font-bold text-[#e07a5f] mb-3">çœŸå€¼è¡¨ç¤ºä¾‹</h3>
            <p class="text-gray-600 mb-4">
                çœŸå€¼è¡¨æ˜¾ç¤ºäº†é€»è¾‘è¡¨è¾¾å¼åœ¨æ‰€æœ‰å¯èƒ½çš„è¾“å…¥ç»„åˆä¸‹çš„çœŸå€¼ï¼š
            </p>
            
            <div class="logic-table">
                <table>
                    <thead>
                        <tr>
                            <th>p</th>
                            <th>q</th>
                            <th>Â¬p</th>
                            <th>p âˆ§ q</th>
                            <th>p âˆ¨ q</th>
                            <th>p â†’ q</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>T</td>
                            <td>T</td>
                            <td>F</td>
                            <td>T</td>
                            <td>T</td>
                            <td>T</td>
                        </tr>
                        <tr>
                            <td>T</td>
                            <td>F</td>
                            <td>F</td>
                            <td>F</td>
                            <td>T</td>
                            <td>F</td>
                        </tr>
                        <tr>
                            <td>F</td>
                            <td>T</td>
                            <td>T</td>
                            <td>F</td>
                            <td>T</td>
                            <td>T</td>
                        </tr>
                        <tr>
                            <td>F</td>
                            <td>F</td>
                            <td>T</td>
                            <td>F</td>
                            <td>F</td>
                            <td>T</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Interactive Truth Table Generator -->
        <div class="concept-card">
            <h3 class="text-xl font-bold text-[#e07a5f] mb-4">äº’åŠ¨å¼çœŸå€¼è¡¨ç”Ÿæˆå™¨</h3>
            <p class="text-gray-600 mb-6">
                è¾“å…¥ä»»æ„é€»è¾‘è¡¨è¾¾å¼ï¼Œç«‹å³ç”Ÿæˆå®Œæ•´çš„çœŸå€¼è¡¨ã€‚æ”¯æŒåˆ†æ­¥è§£æï¼Œå¸®åŠ©æ‚¨ç†è§£å¤æ‚é€»è¾‘è¡¨è¾¾å¼çš„è®¡ç®—è¿‡ç¨‹ã€‚
            </p>
            
            <!-- Input Section -->
            <div class="mb-6">
                <label for="logic-expression" class="block text-sm font-medium text-gray-700 mb-2">
                    é€»è¾‘è¡¨è¾¾å¼è¾“å…¥ï¼š
                </label>
                <div class="flex gap-3">
                    <input 
                        type="text" 
                        id="logic-expression" 
                        placeholder="è¾“å…¥é€»è¾‘è¡¨è¾¾å¼ï¼Œå¦‚ p -> (q && !r)" 
                        class="flex-1 px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-[#e07a5f] focus:border-[#e07a5f] outline-none transition-all"
                        style="font-family: 'Inter', sans-serif;"
                    />
                    <button 
                        id="generate-btn" 
                        class="px-6 py-3 bg-[#e07a5f] text-white font-medium rounded-lg hover:bg-[#d06850] active:bg-[#c55a45] transition-all duration-200 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-[#e07a5f] focus:ring-offset-2"
                    >
                        ç”ŸæˆçœŸå€¼è¡¨
                    </button>
                </div>
                
                <!-- Supported Operators Guide -->
                <div class="mt-4 p-4 bg-[#f8f7f2] rounded-lg border border-gray-200">
                    <h4 class="text-sm font-semibold text-gray-700 mb-2">æ”¯æŒçš„æ“ä½œç¬¦ï¼š</h4>
                    <div class="grid grid-cols-2 md:grid-cols-5 gap-2 text-xs text-gray-600">
                        <div><strong>éï¼š</strong> !, Â¬, NOT</div>
                        <div><strong>ä¸ï¼š</strong> &&, âˆ§, AND</div>
                        <div><strong>æˆ–ï¼š</strong> ||, âˆ¨, OR</div>
                        <div><strong>è•´å«ï¼š</strong> ->, â†’, =></div>
                        <div><strong>ç­‰ä»·ï¼š</strong> <->, â†”, <=></div>
                    </div>
                </div>
            </div>

            <!-- Error Message Area -->
            <div id="error-message" class="hidden mb-4 p-4 bg-red-50 border border-red-200 rounded-lg">
                <div class="flex items-center">
                    <span class="text-red-600 font-medium">âš ï¸ è¯­æ³•é”™è¯¯ï¼š</span>
                    <span id="error-text" class="ml-2 text-red-700"></span>
                </div>
            </div>

            <!-- Generated Truth Table Area -->
            <div id="truth-table-container" class="hidden">
                <h4 class="text-lg font-semibold text-[#e07a5f] mb-4">ç”Ÿæˆçš„çœŸå€¼è¡¨ï¼š</h4>
                <div id="truth-table-content" class="logic-table"></div>
                
                <!-- Analysis Section -->
                <div id="table-analysis" class="mt-4 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                    <h5 class="font-semibold text-blue-800 mb-2">ğŸ“Š è¡¨è¾¾å¼åˆ†æï¼š</h5>
                    <div id="analysis-content" class="text-blue-700 text-sm"></div>
                </div>
            </div>
        </div>

        <style>
            /* Additional styles for the truth table generator */
            #truth-table-container {
                animation: fadeIn 0.5s ease-in-out;
            }
            
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(10px); }
                to { opacity: 1; transform: translateY(0); }
            }
            
            .truth-cell-true {
                background-color: #dcfce7 !important;
                color: #166534;
                font-weight: 600;
            }
            
            .truth-cell-false {
                background-color: #fef2f2 !important;
                color: #dc2626;
                font-weight: 600;
            }
            
            .sub-expression-header {
                background-color: #f3f4f6 !important;
                color: #374151;
                font-size: 0.9em;
                font-style: italic;
            }
        </style>

        <script>
            class TruthTableGenerator {
                constructor() {
                    this.variables = [];
                    this.subExpressions = [];
                    this.operators = {
                        '!': (a) => !a,
                        'Â¬': (a) => !a,
                        'NOT': (a) => !a,
                        '&&': (a, b) => a && b,
                        'âˆ§': (a, b) => a && b,
                        'AND': (a, b) => a && b,
                        '||': (a, b) => a || b,
                        'âˆ¨': (a, b) => a || b,
                        'OR': (a, b) => a || b,
                        '->': (a, b) => !a || b,
                        'â†’': (a, b) => !a || b,
                        '=>': (a, b) => !a || b,
                        '<->': (a, b) => a === b,
                        'â†”': (a, b) => a === b,
                        '<=>': (a, b) => a === b
                    };
                }

                normalizeExpression(expr) {
                    // Convert various operator formats to standard ones
                    return expr
                        .replace(/Â¬/g, '!')
                        .replace(/âˆ§/g, '&&')
                        .replace(/âˆ¨/g, '||')
                        .replace(/â†’/g, '->')
                        .replace(/â†”/g, '<->')
                        .replace(/\bNOT\b/gi, '!')
                        .replace(/\bAND\b/gi, '&&')
                        .replace(/\bOR\b/gi, '||')
                        .replace(/=>/g, '->')
                        .replace(/<=>/g, '<->')
                        .replace(/\s+/g, '');
                }

                extractVariables(expr) {
                    const normalized = this.normalizeExpression(expr);
                    const matches = normalized.match(/[a-zA-Z]+/g) || [];
                    const variables = [...new Set(matches.filter(match => 
                        !['NOT', 'AND', 'OR'].includes(match.toUpperCase())
                    ))];
                    return variables.sort();
                }

                validateExpression(expr) {
                    const normalized = this.normalizeExpression(expr);
                    
                    // Check for balanced parentheses
                    let parenCount = 0;
                    for (let char of normalized) {
                        if (char === '(') parenCount++;
                        if (char === ')') parenCount--;
                        if (parenCount < 0) return "æ‹¬å·æœªé…å¯¹";
                    }
                    if (parenCount !== 0) return "æ‹¬å·æœªé…å¯¹";
                    
                    // Check for valid characters
                    const validChars = /^[a-zA-Z()!&|<>\-=\s]+$/;
                    if (!validChars.test(normalized)) return "åŒ…å«æ— æ•ˆå­—ç¬¦";
                    
                    return null;
                }

                findSubExpressions(expr) {
                    const normalized = this.normalizeExpression(expr);
                    const subExprs = new Set();
                    
                    // Find all parenthesized expressions
                    let parenStack = [];
                    let current = '';
                    
                    for (let i = 0; i < normalized.length; i++) {
                        const char = normalized[i];
                        if (char === '(') {
                            if (parenStack.length > 0) current += char;
                            parenStack.push(i);
                        } else if (char === ')') {
                            if (parenStack.length > 1) current += char;
                            parenStack.pop();
                            if (parenStack.length === 0 && current) {
                                subExprs.add(current);
                                current = '';
                            }
                        } else if (parenStack.length > 0) {
                            current += char;
                        }
                    }
                    
                    // Find binary operations
                    const binaryOps = ['&&', '||', '->', '<->'];
                    for (let op of binaryOps) {
                        let index = normalized.indexOf(op);
                        while (index !== -1) {
                            // Find the operands
                            let left = '', right = '';
                            let leftEnd = index - 1;
                            let rightStart = index + op.length;
                            
                            // Extract left operand
                            if (normalized[leftEnd] === ')') {
                                let parenCount = 1;
                                leftEnd--;
                                while (leftEnd >= 0 && parenCount > 0) {
                                    if (normalized[leftEnd] === ')') parenCount++;
                                    if (normalized[leftEnd] === '(') parenCount--;
                                    leftEnd--;
                                }
                                left = normalized.substring(leftEnd + 1, index);
                            } else {
                                while (leftEnd >= 0 && /[a-zA-Z!]/.test(normalized[leftEnd])) {
                                    leftEnd--;
                                }
                                left = normalized.substring(leftEnd + 1, index);
                            }
                            
                            // Extract right operand
                            if (normalized[rightStart] === '(') {
                                let parenCount = 1;
                                let rightEnd = rightStart + 1;
                                while (rightEnd < normalized.length && parenCount > 0) {
                                    if (normalized[rightEnd] === '(') parenCount++;
                                    if (normalized[rightEnd] === ')') parenCount--;
                                    rightEnd++;
                                }
                                right = normalized.substring(rightStart, rightEnd);
                            } else {
                                let rightEnd = rightStart;
                                while (rightEnd < normalized.length && /[a-zA-Z!]/.test(normalized[rightEnd])) {
                                    rightEnd++;
                                }
                                right = normalized.substring(rightStart, rightEnd);
                            }
                            
                            if (left && right) {
                                subExprs.add(`${left}${op}${right}`);
                            }
                            
                            index = normalized.indexOf(op, index + 1);
                        }
                    }
                    
                    return Array.from(subExprs).filter(expr => expr.length > 1);
                }

                evaluateExpression(expr, assignment) {
                    let normalized = this.normalizeExpression(expr);
                    
                    // Replace variables with their values
                    for (let variable of this.variables) {
                        const regex = new RegExp(`\\b${variable}\\b`, 'g');
                        normalized = normalized.replace(regex, assignment[variable] ? 'true' : 'false');
                    }
                    
                    try {
                        // Replace logical operators with JavaScript equivalents
                        normalized = normalized
                            .replace(/->/g, '||!')
                            .replace(/<->/g, '===');
                        
                        // Handle implication manually
                        normalized = normalized.replace(/true\|\|!false/g, 'true');
                        normalized = normalized.replace(/true\|\|!true/g, 'true');
                        normalized = normalized.replace(/false\|\|!false/g, 'true');
                        normalized = normalized.replace(/false\|\|!true/g, 'false');
                        
                        return eval(normalized);
                    } catch (e) {
                        return false;
                    }
                }

                generateTruthTable(expression) {
                    const error = this.validateExpression(expression);
                    if (error) {
                        throw new Error(error);
                    }

                    this.variables = this.extractVariables(expression);
                    this.subExpressions = this.findSubExpressions(expression);
                    
                    const numRows = Math.pow(2, this.variables.length);
                    const table = [];
                    
                    for (let i = 0; i < numRows; i++) {
                        const assignment = {};
                        const row = {};
                        
                        // Generate truth assignment
                        for (let j = 0; j < this.variables.length; j++) {
                            const value = Boolean(i & (1 << (this.variables.length - 1 - j)));
                            assignment[this.variables[j]] = value;
                            row[this.variables[j]] = value;
                        }
                        
                        // Evaluate sub-expressions
                        for (let subExpr of this.subExpressions) {
                            row[subExpr] = this.evaluateExpression(subExpr, assignment);
                        }
                        
                        // Evaluate main expression
                        row[expression] = this.evaluateExpression(expression, assignment);
                        
                        table.push(row);
                    }
                    
                    return table;
                }

                renderTable(table, expression) {
                    const container = document.getElementById('truth-table-content');
                    
                    // Create table
                    let html = '<table><thead><tr>';
                    
                    // Variable headers
                    for (let variable of this.variables) {
                        html += `<th>${variable}</th>`;
                    }
                    
                    // Sub-expression headers
                    for (let subExpr of this.subExpressions) {
                        html += `<th class="sub-expression-header">${subExpr}</th>`;
                    }
                    
                    // Main expression header
                    html += `<th style="background-color: #e07a5f !important; color: white !important;">${expression}</th>`;
                    html += '</tr></thead><tbody>';
                    
                    // Table rows
                    for (let row of table) {
                        html += '<tr>';
                        
                        // Variable values
                        for (let variable of this.variables) {
                            const value = row[variable];
                            const cellClass = value ? 'truth-cell-true' : 'truth-cell-false';
                            html += `<td class="${cellClass}">${value ? 'T' : 'F'}</td>`;
                        }
                        
                        // Sub-expression values
                        for (let subExpr of this.subExpressions) {
                            const value = row[subExpr];
                            const cellClass = value ? 'truth-cell-true' : 'truth-cell-false';
                            html += `<td class="${cellClass}">${value ? 'T' : 'F'}</td>`;
                        }
                        
                        // Main expression value
                        const mainValue = row[expression];
                        const mainCellClass = mainValue ? 'truth-cell-true' : 'truth-cell-false';
                        html += `<td class="${mainCellClass}" style="font-weight: bold;">${mainValue ? 'T' : 'F'}</td>`;
                        
                        html += '</tr>';
                    }
                    
                    html += '</tbody></table>';
                    container.innerHTML = html;
                    
                    // Generate analysis
                    this.generateAnalysis(table, expression);
                }

                generateAnalysis(table, expression) {
                    const analysisContent = document.getElementById('analysis-content');
                    const trueCount = table.filter(row => row[expression]).length;
                    const totalCount = table.length;
                    const falseCount = totalCount - trueCount;
                    
                    let analysis = `<strong>å˜é‡æ•°é‡ï¼š</strong> ${this.variables.length} (${this.variables.join(', ')})<br>`;
                    analysis += `<strong>æ€»è¡Œæ•°ï¼š</strong> ${totalCount}<br>`;
                    analysis += `<strong>ç»“æœç»Ÿè®¡ï¼š</strong> ${trueCount} ä¸ªçœŸå€¼ï¼Œ${falseCount} ä¸ªå‡å€¼<br>`;
                    
                    if (trueCount === totalCount) {
                        analysis += `<strong>ç±»å‹ï¼š</strong> <span style="color: #059669;">é‡è¨€å¼ (Tautology)</span> - è¡¨è¾¾å¼åœ¨æ‰€æœ‰æƒ…å†µä¸‹éƒ½ä¸ºçœŸ`;
                    } else if (falseCount === totalCount) {
                        analysis += `<strong>ç±»å‹ï¼š</strong> <span style="color: #dc2626;">çŸ›ç›¾å¼ (Contradiction)</span> - è¡¨è¾¾å¼åœ¨æ‰€æœ‰æƒ…å†µä¸‹éƒ½ä¸ºå‡`;
                    } else {
                        analysis += `<strong>ç±»å‹ï¼š</strong> <span style="color: #7c3aed;">å¯æ»¡è¶³å¼ (Contingency)</span> - è¡¨è¾¾å¼çš„çœŸå‡å–å†³äºå˜é‡çš„å€¼`;
                    }
                    
                    if (this.subExpressions.length > 0) {
                        analysis += `<br><strong>åŒ…å«å­è¡¨è¾¾å¼ï¼š</strong> ${this.subExpressions.length} ä¸ª`;
                    }
                    
                    analysisContent.innerHTML = analysis;
                }
            }

            // Initialize the generator
            document.addEventListener('DOMContentLoaded', function() {
                const generator = new TruthTableGenerator();
                const input = document.getElementById('logic-expression');
                const button = document.getElementById('generate-btn');
                const errorDiv = document.getElementById('error-message');
                const errorText = document.getElementById('error-text');
                const tableContainer = document.getElementById('truth-table-container');

                function showError(message) {
                    errorText.textContent = message;
                    errorDiv.classList.remove('hidden');
                    tableContainer.classList.add('hidden');
                }

                function hideError() {
                    errorDiv.classList.add('hidden');
                }

                function generateTable() {
                    const expression = input.value.trim();
                    if (!expression) {
                        showError('è¯·è¾“å…¥é€»è¾‘è¡¨è¾¾å¼');
                        return;
                    }

                    try {
                        hideError();
                        const table = generator.generateTruthTable(expression);
                        generator.renderTable(table, expression);
                        tableContainer.classList.remove('hidden');
                    } catch (error) {
                        showError(error.message);
                    }
                }

                button.addEventListener('click', generateTable);
                input.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        generateTable();
                    }
                });

                // Example expressions for demonstration
                const examples = [
                    'p && q',
                    'p || !q',
                    'p -> q',
                    '(p && q) -> r',
                    '!(p || q) <-> (!p && !q)'
                ];
                
                // Add a subtle hint about examples
                input.addEventListener('focus', function() {
                    if (!this.value) {
                        const randomExample = examples[Math.floor(Math.random() * examples.length)];
                        this.placeholder = `è¯•è¯•è¾“å…¥ï¼š${randomExample}`;
                    }
                });
            });
        </script>

        <!-- Coming Soon Section -->
        <div class="concept-card">
            <h3 class="text-xl font-bold text-[#f4a261] mb-3">å³å°†æ¨å‡º</h3>
            <p class="text-gray-600 mb-4">ç¬¬å››ç« çš„æœ¬åœ°å†…å®¹å°†åŒ…æ‹¬ï¼š</p>
            <ul class="list-disc list-inside space-y-2 ml-4 text-gray-600">
                <li>äº’åŠ¨å¼çœŸå€¼è¡¨ç”Ÿæˆå™¨</li>
                <li>é€»è¾‘ç­‰ä»·è¯æ˜çš„åˆ†æ­¥ç¤ºä¾‹</li>
                <li>å®é™…ç¼–ç¨‹ä¸­çš„é€»è¾‘åº”ç”¨</li>
                <li>é€»è¾‘æ¨ç†ç»ƒä¹ é¢˜åº“</li>
                <li>å¾·æ‘©æ ¹å®šå¾‹çš„å¯è§†åŒ–æ¼”ç¤º</li>
            </ul>
            <p class="text-sm text-gray-500 mt-4 italic">
                è¯·å®šæœŸæŸ¥çœ‹æ›´æ–°ï¼Œæˆ–è®¿é—®Notioné¡µé¢è·å–å®æ—¶å†…å®¹ã€‚
            </p>
        </div>
    </div>
</body>
</html> 